using System;
using System.Collections.Generic;
using System.Text;
using System.Threading;
using System.Threading.Tasks;
using Microsoft.Azure.ServiceBus;
using Newtonsoft.Json;
using Raven.Client.Documents;
using TicketManager.BusinessServices.EventAggregators;
using TicketManager.Contracts.Notifications;
using TicketManager.DataAccess.Documents.DataModel;
using TicketManager.DataAccess.Documents.DataStructures;
using TicketManager.DataAccess.Documents.Extensions;
using TicketManager.Receivers.Configuration;
using TicketManager.Receivers.DataStructures;

namespace TicketManager.Receivers.TicketUserInvolvementChanged
{
    public class TicketUserInvolvementChangedNotificationReceiver : SubscriptionReceiverHostBase<GenericTicketNotification>
    {
        private readonly IDocumentStore documentStore;
        private readonly IEventAggregator<TicketInvolvement> eventAggregator;

        public TicketUserInvolvementChangedNotificationReceiver(ServiceBusSubscriptionConfiguration subscriptionConfiguration, IDocumentStore documentStore, IEventAggregator<TicketInvolvement> eventAggregator)
            : base(subscriptionConfiguration)
        {
            this.documentStore = documentStore ?? throw new ArgumentNullException(nameof(documentStore));
            this.eventAggregator = eventAggregator ?? throw new ArgumentNullException(nameof(eventAggregator));
        }

        public override async Task<ProcessMessageResult> HandleMessageAsync(GenericTicketNotification notification, string correlationId, IDictionary<string, object> headers, CancellationToken cancellationToken)
        {
            while (true)
            {
                using (var session = documentStore.OpenAsyncSession())
                {
                    var ticketCreatedEventId = notification.TicketId;
                    var ticketDocumentId = documentStore.GeneratePrefixedDocumentId<Ticket>(ticketCreatedEventId);
                    var ticketDocument = await session.LoadAsync<Ticket>(ticketDocumentId, cancellationToken).ConfigureAwait(false);

                    var oldConcurrencyStamp = ticketDocument.Involvement.ConcurrencyStamp;
                    var newConcurrencyStamp = Guid.NewGuid().ToString();

                    var updatedInvolvements = await eventAggregator.AggregateSubsequentEventsAsync(ticketCreatedEventId, ticketDocument.Involvement, cancellationToken).ConfigureAwait(false);

                    var updates = new PropertyUpdateBatch<Ticket>()
                        .Add(t => t.Involvement.InvolvedUsersSet, updatedInvolvements.InvolvedUsersSet)
                        .Add(t => t.Involvement.LastKnownAssignmentChangeId, updatedInvolvements.LastKnownAssignmentChangeId)
                        .Add(t => t.Involvement.LastKnownCancelInvolvementId, updatedInvolvements.LastKnownCancelInvolvementId)
                        .Add(t => t.Involvement.LastKnownDescriptionChangeId, updatedInvolvements.LastKnownDescriptionChangeId)
                        .Add(t => t.Involvement.LastKnownLinkChangeId, updatedInvolvements.LastKnownLinkChangeId)
                        .Add(t => t.Involvement.LastKnownPriorityChangeId, updatedInvolvements.LastKnownPriorityChangeId)
                        .Add(t => t.Involvement.LastKnownStatusChangeId, updatedInvolvements.LastKnownStatusChangeId)
                        .Add(t => t.Involvement.LastKnownTagChangeId, updatedInvolvements.LastKnownTagChangeId)
                        .Add(t => t.Involvement.LastKnownTitleChangeId, updatedInvolvements.LastKnownTitleChangeId)
                        .Add(t => t.Involvement.LastKnownTypeChangeId, updatedInvolvements.LastKnownTypeChangeId)
                        .Add(t => t.Involvement.LastKnownStoryPointsChangeId, updatedInvolvements.LastKnownStoryPointsChangeId)
                        .Add(t => t.Involvement.ConcurrencyStamp, newConcurrencyStamp);

                    session.PatchIfEquals(ticketDocumentId, updates, t => t.Involvement.ConcurrencyStamp, oldConcurrencyStamp);

                    await session.SaveChangesAsync(cancellationToken).ConfigureAwait(false);

                    // If the saved document contains the concurrency stamp generated by this handler, then there was no concurrent modification being done so we can be sure that all events that
                    // this handler sees is accounted for. If a concurrent modification occurs, it is possible that the event that caused this handler to run was not seen by the concurrent handler
                    // so we need to try again.
                    if (ticketDocument.Involvement.ConcurrencyStamp == newConcurrencyStamp)
                    {
                        return ProcessMessageResult.Success();
                    }
                }
            }
        }

        protected override bool CanHandleMessage(Message rawMessage)
        {
            // This receiver should react to several different events, so if we can find a TicketId in the message, it is meaningful to this handler.
            var bodyJson = Encoding.UTF8.GetString(rawMessage.Body);
            var body = JsonConvert.DeserializeObject<GenericTicketNotification>(bodyJson);

            return body.TicketId != 0;
        }
    }
}