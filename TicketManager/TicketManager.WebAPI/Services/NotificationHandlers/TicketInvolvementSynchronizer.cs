using System;
using System.Threading;
using System.Threading.Tasks;
using MediatR;
using Raven.Client.Documents;
using TicketManager.DataAccess.Documents.DataModel;
using TicketManager.DataAccess.Documents.DataStructures;
using TicketManager.DataAccess.Documents.Extensions;
using TicketManager.WebAPI.DTOs.Notifications.Abstractions;
using TicketManager.WebAPI.Services.EventAggregators;

namespace TicketManager.WebAPI.Services.NotificationHandlers
{
    public class TicketInvolvementSynchronizer : INotificationHandler<ITicketNotification>
    {
        private readonly IDocumentStore documentStore;
        private readonly IEventAggregator<TicketInvolvement> eventAggregator;

        public TicketInvolvementSynchronizer(IDocumentStore documentStore, IEventAggregator<TicketInvolvement> eventAggregator)
        {
            this.documentStore = documentStore ?? throw new ArgumentNullException(nameof(documentStore));
            this.eventAggregator = eventAggregator ?? throw new ArgumentNullException(nameof(eventAggregator));
        }

        public async Task Handle(ITicketNotification notification, CancellationToken cancellationToken)
        {
            while (true)
            {
                using (var session = documentStore.OpenAsyncSession())
                {
                    var ticketCreatedEventId = notification.TicketId;
                    var ticketDocumentId = documentStore.GeneratePrefixedDocumentId<Ticket>(ticketCreatedEventId);
                    var ticketDocument = await session.LoadAsync<Ticket>(ticketDocumentId, cancellationToken).ConfigureAwait(false);

                    var oldConcurrencyStamp = ticketDocument.Involvement.ConcurrencyStamp;
                    var newConcurrencyStamp = Guid.NewGuid().ToString();

                    var updatedInvolvements = await eventAggregator.AggregateSubsequentEventsAsync(ticketCreatedEventId, ticketDocument.Involvement, cancellationToken).ConfigureAwait(false);

                    var updates = new PropertyUpdateBatch<Ticket>()
                        .Add(t => t.Involvement.InvolvedUsersSet, updatedInvolvements.InvolvedUsersSet)
                        .Add(t => t.Involvement.LastKnownAssignmentChangeId, updatedInvolvements.LastKnownAssignmentChangeId)
                        .Add(t => t.Involvement.LastKnownCancelInvolvementId, updatedInvolvements.LastKnownCancelInvolvementId)
                        .Add(t => t.Involvement.LastKnownDescriptionChangeId, updatedInvolvements.LastKnownDescriptionChangeId)
                        .Add(t => t.Involvement.LastKnownLinkChangeId, updatedInvolvements.LastKnownLinkChangeId)
                        .Add(t => t.Involvement.LastKnownPriorityChangeId, updatedInvolvements.LastKnownPriorityChangeId)
                        .Add(t => t.Involvement.LastKnownStatusChangeId, updatedInvolvements.LastKnownStatusChangeId)
                        .Add(t => t.Involvement.LastKnownTagChangeId, updatedInvolvements.LastKnownTagChangeId)
                        .Add(t => t.Involvement.LastKnownTitleChangeId, updatedInvolvements.LastKnownTitleChangeId)
                        .Add(t => t.Involvement.LastKnownTypeChangeId, updatedInvolvements.LastKnownTypeChangeId)
                        .Add(t => t.Involvement.ConcurrencyStamp, newConcurrencyStamp);

                    session.PatchIfEquals(ticketDocumentId, updates, t => t.Involvement.ConcurrencyStamp, oldConcurrencyStamp);

                    await session.SaveChangesAsync(cancellationToken).ConfigureAwait(false);

                    // If the saved document contains the concurrency stamp generated by this handler, then there was no concurrent modification being done so we can be sure that all events that
                    // this handler sees is accounted for. If a concurrent modification occurs, it is possible that the event that caused this handler to run was not seen by the concurrent handler
                    // so we need to try again.
                    if (ticketDocument.Involvement.ConcurrencyStamp == newConcurrencyStamp)
                    {
                        return;
                    }
                }
            }
        }
    }
}